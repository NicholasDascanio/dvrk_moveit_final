/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2019-12-27 16:16:28.968021
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38;
x0=IKsin(j[0]);
x1=IKcos(j[0]);
x2=IKcos(j[3]);
x3=IKsin(j[4]);
x4=IKsin(j[1]);
x5=IKsin(j[3]);
x6=IKcos(j[1]);
x7=IKcos(j[4]);
x8=((1.299999999935e-12)*x0);
x9=((0.99999999995)*x1);
x10=((9.9999999995e-6)*x1);
x11=((2.9999999985e-5)*x3);
x12=((9.099999999545e-8)*x0);
x13=((1.299999999935e-7)*x1);
x14=((0.99999999955)*x3);
x15=((0.99999999995)*x0);
x16=((0.99999999955)*x7);
x17=((0.1162)*x4);
x18=((1.299999999935e-7)*x0);
x19=((9.099999999545e-8)*x1);
x20=((2.99999999715e-10)*x5);
x21=((0.009099999999545)*x1);
x22=((1.299999999935e-12)*x1);
x23=((2.9999999985e-5)*x7);
x24=((0.009099999999545)*x0);
x25=((2.99999999715e-10)*x2);
x26=((9.9999999995e-6)*x0);
x27=(x2*x6);
x28=(x1*x5);
x29=(x2*x4);
x30=(x0*x4);
x31=(x26*x4);
x32=((((9.9999999995e-6)*x29))+(((-0.99999999995)*x6)));
x33=(x27*x9);
x34=((((9.9999999995e-6)*x6))+(((0.99999999995)*x29)));
x35=(((x10*x4))+((x15*x5)));
x36=(((x5*x9))+((x15*x27)));
x37=(((x4*x9))+((x10*x27))+(((-1.0)*x26*x5)));
x38=((((-1.0)*x10*x5))+(((-1.0)*x15*x4))+(((-1.0)*x26*x27)));
eerot[0]=((((((((((((-9.99999999e-11)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.9999999995e-6)*(((((2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.99999999945)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((9.99999999e-11)*(IKcos(j[0]))*(IKcos(j[3]))))+(((9.9999999995e-6)*(((((-2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKcos(j[4]))))+(((9.9999999995e-6)*(((((0.99999999945)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((0.9999999999)*(IKcos(j[0]))*(IKcos(j[3]))))+(((-0.9999999999)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((0.99999999995)*(((((9.9999999945e-11)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((0.99999999995)*(((((-2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-2.9999999985e-10)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((0.99999999995)*(((((9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((0.99999999945)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((9.99999999e-6)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.99999999e-6)*(IKcos(j[0]))*(IKcos(j[3]))))+(((0.99999999995)*(((((-2.9999999985e-5)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((-0.99999999945)*(IKcos(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-0.99999999945)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))+(((((((-9.999999999e-6)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.999999999e-6)*(IKcos(j[0]))*(IKcos(j[3]))))+(((9.9999999995e-6)*(((((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((9.9999999945e-11)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))))*(IKsin(j[6]))))+(((((((((((-9.999999999e-6)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.999999999e-6)*(IKcos(j[0]))*(IKcos(j[3]))))+(((9.9999999995e-6)*(((((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((9.9999999945e-11)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((-0.99999999995)*(((((-2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKcos(j[4]))))+(((9.99999999e-6)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.99999999e-6)*(IKcos(j[0]))*(IKcos(j[3]))))+(((-0.99999999995)*(((((0.99999999945)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((-0.99999999995)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.99999999945)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((-0.99999999995)*(((((2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((-9.99999999e-11)*(IKcos(j[0]))*(IKcos(j[3]))))+(((9.9999999995e-6)*(((((9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((0.99999999945)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((9.9999999995e-6)*(((((-2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-2.9999999985e-10)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((-2.9999999985e-5)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((9.9999999995e-6)*(((((-0.99999999945)*(IKcos(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-0.99999999945)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))+(((9.99999999e-11)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKcos(j[5]))))+(((((((-0.99999999995)*(((((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))+(((-0.9999999999)*(IKcos(j[0]))*(IKcos(j[3]))))+(((-0.99999999995)*(((((9.9999999945e-11)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((0.9999999999)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKcos(j[5]))))))*(IKcos(j[6])))));
eerot[1]=((((((((((((-9.99999999e-11)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.9999999995e-6)*(((((2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.99999999945)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((9.99999999e-11)*(IKcos(j[0]))*(IKcos(j[3]))))+(((9.9999999995e-6)*(((((-2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKcos(j[4]))))+(((9.9999999995e-6)*(((((0.99999999945)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((0.9999999999)*(IKcos(j[0]))*(IKcos(j[3]))))+(((-0.9999999999)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((0.99999999995)*(((((9.9999999945e-11)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((0.99999999995)*(((((-2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-2.9999999985e-10)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((0.99999999995)*(((((9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((0.99999999945)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((9.99999999e-6)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.99999999e-6)*(IKcos(j[0]))*(IKcos(j[3]))))+(((0.99999999995)*(((((-2.9999999985e-5)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((-0.99999999945)*(IKcos(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-0.99999999945)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))+(((((((-9.999999999e-6)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.999999999e-6)*(IKcos(j[0]))*(IKcos(j[3]))))+(((9.9999999995e-6)*(((((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((9.9999999945e-11)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))))*(IKcos(j[6]))))+(((((((((((-9.99999999e-11)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.99999999e-11)*(IKcos(j[0]))*(IKcos(j[3]))))+(((-9.9999999995e-6)*(((((9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((0.99999999945)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((-9.9999999995e-6)*(((((-2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-2.9999999985e-10)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((-9.9999999995e-6)*(((((-2.9999999985e-5)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((-9.9999999995e-6)*(((((-0.99999999945)*(IKcos(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-0.99999999945)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))+(((((((0.9999999999)*(IKcos(j[0]))*(IKcos(j[3]))))+(((-0.9999999999)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))+(((0.99999999995)*(((((9.9999999945e-11)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))+(((((((-9.9999999995e-6)*(((((9.9999999945e-11)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((-9.999999999e-6)*(IKcos(j[0]))*(IKcos(j[3]))))+(((-9.9999999995e-6)*(((((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))+(((9.999999999e-6)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[5]))))+(((((((9.99999999e-6)*(IKcos(j[0]))*(IKcos(j[3]))))+(((0.99999999995)*(((((2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKsin(j[4]))))+(((0.99999999995)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.99999999945)*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((-2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((0.99999999945)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[0]))))+(((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((-9.99999999e-6)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[5]))))))*(IKsin(j[6])))));
eerot[2]=(((x11*(((((-1.0)*x31))+x36))))+((x23*x38))+((x1*x25))+((x14*x38))+(((-1.0)*x0*x20*x6))+((x16*(((((-1.0)*x36))+x31)))));
IkReal x39=((1.0)*x27);
IkReal x40=((1.0)*x5);
eetrans[0]=(((j[2]*x30))+((x3*(((((-1.0)*x18*x4))+(((-1.0)*x22*x40))+(((-1.0)*x39*x8))))))+((x0*x17))+((x7*((((x19*x5))+((x12*x27))+((x24*x4))))))+((x7*(((((-1.0)*x18*x39))+((x4*x8))+(((-1.0)*x13*x40))))))+(((0.043)*x1))+((x3*(((((-1.0)*x21*x40))+(((-1.0)*x24*x39))+((x12*x4)))))));
eerot[3]=((((((((((((9.999999999e-6)*(IKsin(j[1]))*(IKsin(j[3]))))+(((9.9999999995e-6)*(((((9.9999999945e-11)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((-9.9999999945e-11)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((9.9999999995e-6)*(((((-2.9999999985e-10)*(IKcos(j[3]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKcos(j[1]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((-0.99999999945)*(IKcos(j[3]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[1]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((-0.99999999945)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((9.99999999e-11)*(IKsin(j[1]))*(IKsin(j[3]))))+(((9.9999999995e-6)*(((((-2.9999999985e-10)*(IKcos(j[1]))))+(((-2.9999999985e-5)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((0.9999999999)*(IKsin(j[1]))*(IKsin(j[3]))))+(((0.99999999995)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((-9.9999999945e-11)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((9.9999999945e-11)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((0.99999999995)*(((((2.9999999985e-10)*(IKcos(j[3]))*(IKsin(j[1]))))+(((-2.9999999985e-5)*(IKcos(j[1]))))))*(IKsin(j[4]))))+(((0.99999999995)*(((((2.9999999985e-5)*(IKcos(j[3]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[1]))))))*(IKcos(j[4]))))+(((-9.99999999e-6)*(IKsin(j[1]))*(IKsin(j[3]))))+(((0.99999999995)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((0.99999999945)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((0.99999999995)*(((((-9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[1]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))))*(IKsin(j[6]))))+(((((((((((-0.99999999995)*(((((9.9999999945e-11)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((-0.9999999999)*(IKsin(j[1]))*(IKsin(j[3]))))+(((-0.99999999995)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((-9.9999999945e-11)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((9.999999999e-6)*(IKsin(j[1]))*(IKsin(j[3]))))+(((9.9999999995e-6)*(((((9.9999999945e-11)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((-9.9999999945e-11)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((-9.99999999e-6)*(IKsin(j[1]))*(IKsin(j[3]))))+(((-0.99999999995)*(((((-0.99999999945)*(IKcos(j[3]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[1]))))))*(IKsin(j[4]))))+(((-0.99999999995)*(((((-0.99999999945)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((-0.99999999995)*(((((-2.9999999985e-10)*(IKcos(j[1]))))+(((-2.9999999985e-5)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((-0.99999999995)*(((((-2.9999999985e-10)*(IKcos(j[3]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKcos(j[1]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((9.9999999995e-6)*(((((2.9999999985e-5)*(IKcos(j[3]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[1]))))))*(IKcos(j[4]))))+(((9.9999999995e-6)*(((((-9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[1]))))))*(IKcos(j[4]))))+(((9.9999999995e-6)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((0.99999999945)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((-9.99999999e-11)*(IKsin(j[1]))*(IKsin(j[3]))))+(((9.9999999995e-6)*(((((2.9999999985e-10)*(IKcos(j[3]))*(IKsin(j[1]))))+(((-2.9999999985e-5)*(IKcos(j[1]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))))*(IKcos(j[6])))));
eerot[4]=((((((((((((0.9999999999)*(IKsin(j[1]))*(IKsin(j[3]))))+(((0.99999999995)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((-9.9999999945e-11)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((9.9999999945e-11)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))+(((((((-9.9999999995e-6)*(((((9.9999999945e-11)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((-9.999999999e-6)*(IKsin(j[1]))*(IKsin(j[3]))))+(((-9.9999999995e-6)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((-9.9999999945e-11)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((0.99999999995)*(((((-2.9999999985e-10)*(IKcos(j[3]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKcos(j[1]))))))*(IKsin(j[4]))))+(((9.99999999e-6)*(IKsin(j[1]))*(IKsin(j[3]))))+(((0.99999999995)*(((((-0.99999999945)*(IKcos(j[3]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[1]))))))*(IKsin(j[4]))))+(((0.99999999995)*(((((-0.99999999945)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((-2.9999999985e-10)*(IKcos(j[1]))))+(((-2.9999999985e-5)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((-9.9999999995e-6)*(((((2.9999999985e-5)*(IKcos(j[3]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[1]))))))*(IKcos(j[4]))))+(((-9.9999999995e-6)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((0.99999999945)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((-9.9999999995e-6)*(((((2.9999999985e-10)*(IKcos(j[3]))*(IKsin(j[1]))))+(((-2.9999999985e-5)*(IKcos(j[1]))))))*(IKsin(j[4]))))+(((-9.9999999995e-6)*(((((-9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[1]))))))*(IKcos(j[4]))))+(((9.99999999e-11)*(IKsin(j[1]))*(IKsin(j[3]))))))*(IKcos(j[5]))))))*(IKsin(j[6]))))+(((((((((((9.999999999e-6)*(IKsin(j[1]))*(IKsin(j[3]))))+(((9.9999999995e-6)*(((((9.9999999945e-11)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((-9.9999999945e-11)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((9.9999999995e-6)*(((((-2.9999999985e-10)*(IKcos(j[3]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKcos(j[1]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((-0.99999999945)*(IKcos(j[3]))*(IKsin(j[1]))))+(((-9.9999999945e-6)*(IKcos(j[1]))))))*(IKsin(j[4]))))+(((9.9999999995e-6)*(((((-0.99999999945)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((9.99999999e-11)*(IKsin(j[1]))*(IKsin(j[3]))))+(((9.9999999995e-6)*(((((-2.9999999985e-10)*(IKcos(j[1]))))+(((-2.9999999985e-5)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((0.9999999999)*(IKsin(j[1]))*(IKsin(j[3]))))+(((0.99999999995)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((-9.9999999945e-11)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((9.9999999945e-11)*(IKcos(j[1]))))+(((9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((0.99999999995)*(((((2.9999999985e-10)*(IKcos(j[3]))*(IKsin(j[1]))))+(((-2.9999999985e-5)*(IKcos(j[1]))))))*(IKsin(j[4]))))+(((0.99999999995)*(((((2.9999999985e-5)*(IKcos(j[3]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[1]))))))*(IKcos(j[4]))))+(((-9.99999999e-6)*(IKsin(j[1]))*(IKsin(j[3]))))+(((0.99999999995)*(((((9.9999999945e-6)*(IKcos(j[1]))))+(((0.99999999945)*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((0.99999999995)*(((((-9.9999999945e-6)*(IKcos(j[3]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[1]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))))*(IKcos(j[6])))));
eerot[5]=(((x23*x32))+((x16*x34))+((x14*x32))+(((-1.0)*x11*x34))+((x20*x4)));
eetrans[1]=(((x3*(((((1.299999999935e-12)*x29))+(((-1.299999999935e-7)*x6))))))+((x7*(((((-9.099999999545e-8)*x29))+(((0.009099999999545)*x6))))))+(((0.1162)*x6))+((x7*(((((1.299999999935e-7)*x29))+(((1.299999999935e-12)*x6))))))+((x3*(((((9.099999999545e-8)*x6))+(((0.009099999999545)*x29))))))+((j[2]*x6)));
eerot[6]=((((((((((((-9.9999999995e-6)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((-9.9999999995e-6)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-9.999999999e-6)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-9.999999999e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))))*(IKcos(j[5]))))+(((((((-9.9999999995e-6)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((0.99999999945)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-9.99999999e-11)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-9.9999999995e-6)*(((((9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((-0.99999999945)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((0.99999999945)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((-9.9999999995e-6)*(((((2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-9.99999999e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((-9.9999999995e-6)*(((((-2.9999999985e-10)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((-0.9999999999)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.99999999995)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((-0.9999999999)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((-0.99999999995)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((9.99999999e-6)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.99999999995)*(((((-2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKsin(j[4]))))+(((-0.99999999995)*(((((-2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[1]))))+(((-2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((9.99999999e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((-0.99999999995)*(((((-0.99999999945)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-0.99999999995)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-0.99999999945)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))))*(IKsin(j[6]))))+(((((((((((-9.9999999995e-6)*(((((-2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[1]))))+(((-2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-9.9999999995e-6)*(((((-0.99999999945)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-9.9999999995e-6)*(((((-2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKsin(j[4]))))+(((9.99999999e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((9.99999999e-11)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-9.9999999995e-6)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-0.99999999945)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))+(((((((-9.9999999995e-6)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((-9.9999999995e-6)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-9.999999999e-6)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-9.999999999e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))))*(IKsin(j[5]))))+(((((((0.99999999995)*(((((9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((-0.99999999945)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((0.99999999945)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((9.99999999e-6)*(IKcos(j[3]))*(IKsin(j[0]))))+(((0.99999999995)*(((((-2.9999999985e-10)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((0.99999999995)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((0.99999999945)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((9.99999999e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((0.99999999995)*(((((2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((0.9999999999)*(IKcos(j[3]))*(IKsin(j[0]))))+(((0.9999999999)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((0.99999999995)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((0.99999999995)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[1]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))))*(IKcos(j[6])))));
eerot[7]=((((((((((((-9.9999999995e-6)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((-9.9999999995e-6)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-9.999999999e-6)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-9.999999999e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))))*(IKcos(j[5]))))+(((((((-9.9999999995e-6)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((0.99999999945)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-9.99999999e-11)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-9.9999999995e-6)*(((((9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((-0.99999999945)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((0.99999999945)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((-9.9999999995e-6)*(((((2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-9.99999999e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((-9.9999999995e-6)*(((((-2.9999999985e-10)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((-0.9999999999)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.99999999995)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((-0.9999999999)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((-0.99999999995)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((9.99999999e-6)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.99999999995)*(((((-2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKsin(j[4]))))+(((-0.99999999995)*(((((-2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[1]))))+(((-2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((9.99999999e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((-0.99999999995)*(((((-0.99999999945)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-0.99999999995)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-0.99999999945)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))))*(IKcos(j[5]))))))*(IKcos(j[6]))))+(((((((((((-0.9999999999)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.99999999995)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((-0.9999999999)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((-0.99999999995)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((-9.99999999e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((-0.99999999995)*(((((2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-0.99999999995)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((0.99999999945)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((-0.99999999995)*(((((-2.9999999985e-10)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((-9.99999999e-6)*(IKcos(j[3]))*(IKsin(j[0]))))+(((-0.99999999995)*(((((9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((-0.99999999945)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((0.99999999945)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((((((9.9999999995e-6)*(((((-9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((9.999999999e-6)*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.999999999e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((9.9999999995e-6)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-11)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((9.9999999995e-6)*(((((-9.9999999945e-6)*(IKcos(j[0]))*(IKsin(j[1]))))+(((0.99999999945)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))+(((-0.99999999945)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((-9.99999999e-11)*(IKcos(j[3]))*(IKsin(j[0]))))+(((9.9999999995e-6)*(((((-2.9999999985e-10)*(IKsin(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKsin(j[1]))))+(((2.9999999985e-10)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKsin(j[4]))))+(((-9.99999999e-11)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[3]))))+(((9.9999999995e-6)*(((((-0.99999999945)*(IKcos(j[0]))*(IKsin(j[1]))))+(((9.9999999945e-6)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-9.9999999945e-6)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((9.9999999995e-6)*(((((-2.9999999985e-10)*(IKcos(j[0]))*(IKsin(j[1]))))+(((-2.9999999985e-5)*(IKsin(j[0]))*(IKsin(j[3]))))+(((2.9999999985e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))))*(IKsin(j[6])))));
IkReal x41=((1.0)*x37);
eerot[8]=((((-1.0)*x23*x41))+(((-1.0)*x0*x25))+(((-1.0)*x16*(((((-1.0)*x35))+x33))))+(((-1.0)*x11*(((((-1.0)*x33))+x35))))+(((-1.0)*x14*x41))+(((-1.0)*x1*x20*x6)));
IkReal x42=((1.0)*x13);
IkReal x43=((1.0)*x27);
eetrans[2]=((((-0.043)*x0))+((j[2]*x1*x4))+((x3*((((x19*x4))+(((-1.0)*x21*x43))+((x24*x5))))))+((x1*x17))+((x7*(((((-1.0)*x12*x5))+((x19*x27))+((x21*x4))))))+((x3*(((((-1.0)*x22*x43))+((x5*x8))+(((-1.0)*x4*x42))))))+((x7*((((x18*x5))+((x22*x4))+(((-1.0)*x27*x42)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {1}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j1,cj1,sj1,htj1,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij1[2], _nj1;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij1[0] = -1; _ij1[1] = -1; _nj1 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j1=pfree[0]; cj1=cos(pfree[0]); sj1=sin(pfree[0]), htj1=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=px;
new_r10=((-1.0)*r20);
new_r11=((-1.0)*r21);
new_r12=((-1.0)*r22);
new_py=((-1.0)*pz);
new_r20=r10;
new_r21=r11;
new_r22=r12;
new_pz=py;
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x44=((1.0)*px);
IkReal x45=((1.0)*pz);
IkReal x46=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x46))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x45)));
rxp0_2=((((-1.0)*r10*x44))+((py*r00)));
rxp1_0=((((-1.0)*r21*x46))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x45)));
rxp1_2=((((-1.0)*r11*x44))+((py*r01)));
rxp2_0=((((-1.0)*r22*x46))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x45))+((px*r22)));
rxp2_2=((((-1.0)*r12*x44))+((py*r02)));
{
IkReal j2eval[1];
j2eval[0]=cj1;
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
j0eval[0]=((px*px)+(py*py));
j0eval[1]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x47=pz*pz;
IkReal x48=px*px;
IkReal x49=r01*r01;
IkReal x50=r21*r21;
IkReal x51=r00*r00;
IkReal x52=r10*r10;
IkReal x53=py*py;
IkReal x54=r11*r11;
IkReal x55=r20*r20;
IkReal x56=r12*r12;
IkReal x57=r22*r22;
IkReal x58=r02*r02;
IkReal x59=((25000000.0)*x47);
IkReal x60=((25000000.0)*x51);
IkReal x61=((25000000.0)*x53);
IkReal x62=(x50*x54);
IkReal x63=(x56*x57);
IkReal x64=(x49*x50);
IkReal x65=(x52*x53);
IkReal x66=((25000000.0)*x48*x49);
IkReal x67=((25000000.0)*x48*x58);
if((((-46225.0)+(((25000000.0)*x48*x64))+(((-50000000.0)*x48*x49*x51))+(((-1.0)*x56*x67))+(((-1.0)*x61*x63))+((x48*x52*x60))+((x49*x54*x61))+((x59*x64))+((x59*x62))+((x51*x55*x59))+(((-50000000.0)*x47*x50*x55))+(((-1.0)*x56*x58*x61))+((x60*x65))+(((-1.0)*x57*x58*x59))+((x61*x62))+(((-1.0)*x59*x63))+((x57*x59))+((x50*x59))+(((-50000000.0)*x54*x65))+x66+x67+((x56*x61))+((x52*x55*x61))+((x52*x55*x59))+((x48*x60))+((x52*x61))+(((-1.0)*x57*x67))+((x48*x55*x60))+((x54*x66))+((x54*x61))+((x55*x59)))) < -0.00001)
continue;
IkReal x68=((0.0002)*(IKsqrt(((-46225.0)+(((25000000.0)*x48*x64))+(((-50000000.0)*x48*x49*x51))+(((-1.0)*x56*x67))+(((-1.0)*x61*x63))+((x48*x52*x60))+((x49*x54*x61))+((x59*x64))+((x59*x62))+((x51*x55*x59))+(((-50000000.0)*x47*x50*x55))+(((-1.0)*x56*x58*x61))+((x60*x65))+(((-1.0)*x57*x58*x59))+((x61*x62))+(((-1.0)*x59*x63))+((x57*x59))+((x50*x59))+(((-50000000.0)*x54*x65))+x66+x67+((x56*x61))+((x52*x55*x61))+((x52*x55*x59))+((x48*x60))+((x52*x61))+(((-1.0)*x57*x67))+((x48*x55*x60))+((x54*x66))+((x54*x61))+((x55*x59))))));
j2array[0]=((-0.1162)+(((-1.0)*x68)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((-0.1162)+x68);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
j2valid[0] = true;
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[3];
IkReal x69=pz*pz;
IkReal x70=(px*sj1);
IkReal x71=((1000.0)*j2);
IkReal x72=(py*sj1);
j0eval[0]=(pp+(((-1.0)*x69)));
j0eval[1]=IKsign(((((-1000.0)*x69))+(((1000.0)*pp))));
j0eval[2]=((IKabs(((((-116.2)*x72))+(((-1.0)*x71*x72))+(((43.0)*px)))))+(IKabs(((((43.0)*py))+((x70*x71))+(((116.2)*x70))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x73=pz*pz;
IkReal x74=((43.0)*sj1);
IkReal x75=(pp*sj1);
IkReal x76=((1000.0)*j2);
IkReal x77=(sj1*x73);
IkReal x78=((1000.0)*cj1*pz);
j0eval[0]=(x75+(((-1.0)*x77)));
j0eval[1]=IKsign(((((1000.0)*x75))+(((-1000.0)*x77))));
j0eval[2]=((IKabs((((py*x78))+(((-116.2)*py))+(((-1.0)*py*x76))+((px*x74)))))+(IKabs((((py*x74))+(((116.2)*px))+(((-1.0)*px*x78))+((px*x76))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[2];
sj1=0;
cj1=1.0;
j1=0;
IkReal x79=pz*pz;
j0eval[0]=(pp+(((-1.0)*x79)));
j0eval[1]=IKsign(((((-1000.0)*x79))+(((1000.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0, j3]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x80 = IKatan2WithCheck(IkReal(((43.0)*py)),IkReal(((43.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x80.valid){
continue;
}
CheckValue<IkReal> x81=IKPowWithIntegerCheck(IKsign(((((-1000.0)*(pz*pz)))+(((1000.0)*pp)))),-1);
if(!x81.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x80.value)+(((1.5707963267949)*(x81.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x82=IKcos(j0);
IkReal x83=IKsin(j0);
evalcond[0]=((-0.043)+((py*x83))+((px*x82)));
evalcond[1]=((((-1.0)*px*x83))+((py*x82)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[1];
sj1=0;
cj1=1.0;
j1=0;
j3eval[0]=((IKabs((((px*sj0))+(((-1.0)*cj0*py)))))+(IKabs(((-0.043)+((cj0*px))+((py*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
sj1=0;
cj1=1.0;
j1=0;
IkReal x84=((1.0)*py);
j3eval[0]=((IKabs(((0.043)+(((-1.0)*sj0*x84))+(((-1.0)*cj0*px)))))+(IKabs(((((-1.0)*cj0*x84))+((px*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x85=((1.0)*cj0);
CheckValue<IkReal> x87 = IKatan2WithCheck(IkReal(((0.043)+(((-1.0)*py*sj0))+(((-1.0)*px*x85)))),IkReal(((((-1.0)*py*x85))+((px*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x87.valid){
continue;
}
IkReal x86=x87.value;
j3array[0]=((-1.0)*x86);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x86)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x88=IKsin(j3);
IkReal x89=IKcos(j3);
evalcond[0]=((((-1.0)*cj0*py*x89))+((px*sj0*x89))+(((-0.043)*x88))+((cj0*px*x88))+((py*sj0*x88)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x169 = IKatan2WithCheck(IkReal((((px*sj0))+(((-1.0)*cj0*py)))),IkReal(((-0.043)+((cj0*px))+((py*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x169.valid){
continue;
}
IkReal x168=x169.value;
j3array[0]=((-1.0)*x168);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x168)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x170=IKcos(j3);
IkReal x171=IKsin(j3);
IkReal x172=((1.0)*cj0);
evalcond[0]=((((0.043)*x170))+(((-1.0)*px*x170*x172))+(((-1.0)*py*sj0*x170))+(((-1.0)*py*x171*x172))+((px*sj0*x171)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[2];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x173=pz*pz;
j0eval[0]=((((-1.0)*x173))+pp);
j0eval[1]=IKsign(((((-1000.0)*x173))+(((1000.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0, j3]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x174 = IKatan2WithCheck(IkReal(((43.0)*py)),IkReal(((43.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x174.valid){
continue;
}
CheckValue<IkReal> x175=IKPowWithIntegerCheck(IKsign(((((-1000.0)*(pz*pz)))+(((1000.0)*pp)))),-1);
if(!x175.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x174.value)+(((1.5707963267949)*(x175.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x176=IKcos(j0);
IkReal x177=IKsin(j0);
evalcond[0]=((-0.043)+((py*x177))+((px*x176)));
evalcond[1]=(((py*x176))+(((-1.0)*px*x177)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j3eval[0]=((IKabs(((((-1.0)*px*sj0))+((cj0*py)))))+(IKabs(((-0.043)+((cj0*px))+((py*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x178=((1.0)*sj0);
j3eval[0]=((IKabs(((0.043)+(((-1.0)*py*x178))+(((-1.0)*cj0*px)))))+(IKabs(((((-1.0)*px*x178))+((cj0*py))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x179=((1.0)*px);
CheckValue<IkReal> x181 = IKatan2WithCheck(IkReal(((0.043)+(((-1.0)*cj0*x179))+(((-1.0)*py*sj0)))),IkReal(((((-1.0)*sj0*x179))+((cj0*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x181.valid){
continue;
}
IkReal x180=x181.value;
j3array[0]=((-1.0)*x180);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x180)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x182=IKsin(j3);
IkReal x183=IKcos(j3);
evalcond[0]=(((cj0*py*x183))+(((-0.043)*x182))+((cj0*px*x182))+(((-1.0)*px*sj0*x183))+((py*sj0*x182)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x185 = IKatan2WithCheck(IkReal(((((-1.0)*px*sj0))+((cj0*py)))),IkReal(((-0.043)+((cj0*px))+((py*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x185.valid){
continue;
}
IkReal x184=x185.value;
j3array[0]=((-1.0)*x184);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x184)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x186=IKcos(j3);
IkReal x187=IKsin(j3);
IkReal x188=((1.0)*px);
evalcond[0]=(((cj0*py*x187))+(((0.043)*x186))+(((-1.0)*cj0*x186*x188))+(((-1.0)*py*sj0*x186))+(((-1.0)*sj0*x187*x188)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x189=((43.0)*sj1);
IkReal x190=((1000.0)*sj1);
IkReal x191=((1000.0)*j2);
IkReal x192=((1000.0)*cj1*pz);
CheckValue<IkReal> x193 = IKatan2WithCheck(IkReal(((((116.2)*px))+((px*x191))+(((-1.0)*px*x192))+((py*x189)))),IkReal(((((-1.0)*py*x191))+(((-116.2)*py))+((px*x189))+((py*x192)))),IKFAST_ATAN2_MAGTHRESH);
if(!x193.valid){
continue;
}
CheckValue<IkReal> x194=IKPowWithIntegerCheck(IKsign(((((-1.0)*x190*(pz*pz)))+((pp*x190)))),-1);
if(!x194.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x193.value)+(((1.5707963267949)*(x194.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x195=IKcos(j0);
IkReal x196=IKsin(j0);
IkReal x197=(py*x195);
IkReal x198=(px*x196);
evalcond[0]=((-0.043)+((px*x195))+((py*x196)));
evalcond[1]=((((-1.0)*x198))+x197+((j2*sj1))+(((0.1162)*sj1)));
evalcond[2]=((-0.1162)+((sj1*x198))+((cj1*pz))+(((-1.0)*j2))+(((-1.0)*sj1*x197)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[1];
j3eval[0]=((IKabs(((((-1.0)*cj0*cj1*py))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))))+(IKabs(((-0.043)+((cj0*px))+((py*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
IkReal x199=((1.0)*cj0);
j3eval[0]=((IKabs(((((-1.0)*pz*sj1))+((cj1*px*sj0))+(((-1.0)*cj1*py*x199)))))+(IKabs(((0.043)+(((-1.0)*py*sj0))+(((-1.0)*px*x199))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x200=((1.0)*cj0);
CheckValue<IkReal> x202 = IKatan2WithCheck(IkReal(((0.043)+(((-1.0)*px*x200))+(((-1.0)*py*sj0)))),IkReal(((((-1.0)*pz*sj1))+(((-1.0)*cj1*py*x200))+((cj1*px*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x202.valid){
continue;
}
IkReal x201=x202.value;
j3array[0]=((-1.0)*x201);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x201)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x203=IKsin(j3);
IkReal x204=IKcos(j3);
IkReal x205=(cj1*x204);
evalcond[0]=(((py*sj0*x203))+(((-1.0)*cj0*py*x205))+((px*sj0*x205))+(((-0.043)*x203))+(((-1.0)*pz*sj1*x204))+((cj0*px*x203)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x207 = IKatan2WithCheck(IkReal(((((-1.0)*cj0*cj1*py))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))),IkReal(((-0.043)+((cj0*px))+((py*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x207.valid){
continue;
}
IkReal x206=x207.value;
j3array[0]=((-1.0)*x206);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x206)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x208=IKsin(j3);
IkReal x209=IKcos(j3);
IkReal x210=((1.0)*x208);
IkReal x211=((1.0)*x209);
evalcond[0]=((((0.043)*x209))+(((-1.0)*cj0*cj1*py*x210))+(((-1.0)*cj0*px*x211))+(((-1.0)*py*sj0*x211))+(((-1.0)*pz*sj1*x210))+((cj1*px*sj0*x208)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x212=(px*sj1);
IkReal x213=((1000.0)*j2);
IkReal x214=(py*sj1);
CheckValue<IkReal> x215=IKPowWithIntegerCheck(IKsign(((((-1000.0)*(pz*pz)))+(((1000.0)*pp)))),-1);
if(!x215.valid){
continue;
}
CheckValue<IkReal> x216 = IKatan2WithCheck(IkReal(((((116.2)*x212))+((x212*x213))+(((43.0)*py)))),IkReal(((((43.0)*px))+(((-1.0)*x213*x214))+(((-116.2)*x214)))),IKFAST_ATAN2_MAGTHRESH);
if(!x216.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x215.value)))+(x216.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x217=IKcos(j0);
IkReal x218=IKsin(j0);
IkReal x219=(py*x217);
IkReal x220=(px*x218);
evalcond[0]=((-0.043)+((py*x218))+((px*x217)));
evalcond[1]=(x219+((j2*sj1))+(((0.1162)*sj1))+(((-1.0)*x220)));
evalcond[2]=((-0.1162)+(((-1.0)*sj1*x219))+((cj1*pz))+((sj1*x220))+(((-1.0)*j2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[1];
j3eval[0]=((IKabs(((((-1.0)*cj0*cj1*py))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))))+(IKabs(((-0.043)+((cj0*px))+((py*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
IkReal x221=((1.0)*cj0);
j3eval[0]=((IKabs(((0.043)+(((-1.0)*py*sj0))+(((-1.0)*px*x221)))))+(IKabs(((((-1.0)*pz*sj1))+(((-1.0)*cj1*py*x221))+((cj1*px*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x222=((1.0)*cj0);
CheckValue<IkReal> x224 = IKatan2WithCheck(IkReal(((0.043)+(((-1.0)*py*sj0))+(((-1.0)*px*x222)))),IkReal(((((-1.0)*pz*sj1))+(((-1.0)*cj1*py*x222))+((cj1*px*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x224.valid){
continue;
}
IkReal x223=x224.value;
j3array[0]=((-1.0)*x223);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x223)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x225=IKsin(j3);
IkReal x226=IKcos(j3);
IkReal x227=(cj1*x226);
evalcond[0]=((((-1.0)*cj0*py*x227))+((px*sj0*x227))+(((-1.0)*pz*sj1*x226))+(((-0.043)*x225))+((cj0*px*x225))+((py*sj0*x225)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x229 = IKatan2WithCheck(IkReal(((((-1.0)*cj0*cj1*py))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))),IkReal(((-0.043)+((cj0*px))+((py*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x229.valid){
continue;
}
IkReal x228=x229.value;
j3array[0]=((-1.0)*x228);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x228)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x230=IKsin(j3);
IkReal x231=IKcos(j3);
IkReal x232=((1.0)*x230);
IkReal x233=((1.0)*x231);
evalcond[0]=((((0.043)*x231))+(((-1.0)*py*sj0*x233))+(((-1.0)*pz*sj1*x232))+(((-1.0)*cj0*cj1*py*x232))+(((-1.0)*cj0*px*x233))+((cj1*px*sj0*x230)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x236 = IKatan2WithCheck(IkReal(px),IkReal(py),IKFAST_ATAN2_MAGTHRESH);
if(!x236.valid){
continue;
}
IkReal x234=((1.0)*(x236.value));
if((((px*px)+(py*py))) < -0.00001)
continue;
CheckValue<IkReal> x237=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);
if(!x237.valid){
continue;
}
if( (((0.043)*(x237.value))) < -1-IKFAST_SINCOS_THRESH || (((0.043)*(x237.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x235=IKasin(((0.043)*(x237.value)));
j0array[0]=((((-1.0)*x234))+x235);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x234))+(((-1.0)*x235)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
j2array[0]=((-0.1162)+(((-1.0)*cj0*py*sj1))+((px*sj0*sj1))+((cj1*pz)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j3eval[1];
j3eval[0]=((IKabs(((((-1.0)*cj0*cj1*py))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))))+(IKabs(((-0.043)+((cj0*px))+((py*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
IkReal x238=((1.0)*cj0);
j3eval[0]=((IKabs(((0.043)+(((-1.0)*px*x238))+(((-1.0)*py*sj0)))))+(IKabs(((((-1.0)*cj1*py*x238))+(((-1.0)*pz*sj1))+((cj1*px*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x239=((1.0)*cj0);
CheckValue<IkReal> x241 = IKatan2WithCheck(IkReal(((0.043)+(((-1.0)*px*x239))+(((-1.0)*py*sj0)))),IkReal(((((-1.0)*cj1*py*x239))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x241.valid){
continue;
}
IkReal x240=x241.value;
j3array[0]=((-1.0)*x240);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x240)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x242=IKsin(j3);
IkReal x243=IKcos(j3);
IkReal x244=(cj1*x243);
evalcond[0]=(((px*sj0*x244))+(((-0.043)*x242))+((py*sj0*x242))+((cj0*px*x242))+(((-1.0)*pz*sj1*x243))+(((-1.0)*cj0*py*x244)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x246 = IKatan2WithCheck(IkReal(((((-1.0)*cj0*cj1*py))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))),IkReal(((-0.043)+((cj0*px))+((py*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x246.valid){
continue;
}
IkReal x245=x246.value;
j3array[0]=((-1.0)*x245);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x245)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x247=IKsin(j3);
IkReal x248=IKcos(j3);
IkReal x249=((1.0)*x247);
IkReal x250=((1.0)*x248);
evalcond[0]=(((cj1*px*sj0*x247))+(((-1.0)*cj0*cj1*py*x249))+(((-1.0)*py*sj0*x250))+(((0.043)*x248))+(((-1.0)*cj0*px*x250))+(((-1.0)*pz*sj1*x249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
CheckValue<IkReal> x251=IKPowWithIntegerCheck(cj1,-1);
if(!x251.valid){
continue;
}
j2array[0]=((-0.1162)+((pz*(x251.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[3];
IkReal x252=pz*pz;
IkReal x253=(px*sj1);
IkReal x254=((1000.0)*j2);
IkReal x255=(py*sj1);
j0eval[0]=(pp+(((-1.0)*x252)));
j0eval[1]=IKsign(((((-1000.0)*x252))+(((1000.0)*pp))));
j0eval[2]=((IKabs((((x253*x254))+(((43.0)*py))+(((116.2)*x253)))))+(IKabs(((((-116.2)*x255))+(((-1.0)*x254*x255))+(((43.0)*px))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x256=pz*pz;
IkReal x257=((43.0)*sj1);
IkReal x258=(pp*sj1);
IkReal x259=((1000.0)*j2);
IkReal x260=(sj1*x256);
IkReal x261=((1000.0)*cj1*pz);
j0eval[0]=((((-1.0)*x260))+x258);
j0eval[1]=IKsign(((((-1000.0)*x260))+(((1000.0)*x258))));
j0eval[2]=((IKabs(((((116.2)*px))+((py*x257))+((px*x259))+(((-1.0)*px*x261)))))+(IKabs(((((-116.2)*py))+((px*x257))+(((-1.0)*py*x259))+((py*x261))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[2];
sj1=0;
cj1=1.0;
j1=0;
IkReal x262=pz*pz;
j0eval[0]=((((-1.0)*x262))+pp);
j0eval[1]=IKsign(((((-1000.0)*x262))+(((1000.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0, j3]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x263 = IKatan2WithCheck(IkReal(((43.0)*py)),IkReal(((43.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x263.valid){
continue;
}
CheckValue<IkReal> x264=IKPowWithIntegerCheck(IKsign(((((-1000.0)*(pz*pz)))+(((1000.0)*pp)))),-1);
if(!x264.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x263.value)+(((1.5707963267949)*(x264.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x265=IKcos(j0);
IkReal x266=IKsin(j0);
evalcond[0]=((-0.043)+((py*x266))+((px*x265)));
evalcond[1]=((((-1.0)*px*x266))+((py*x265)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[1];
sj1=0;
cj1=1.0;
j1=0;
j3eval[0]=((IKabs((((px*sj0))+(((-1.0)*cj0*py)))))+(IKabs(((-0.043)+((cj0*px))+((py*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
sj1=0;
cj1=1.0;
j1=0;
IkReal x267=((1.0)*py);
j3eval[0]=((IKabs(((0.043)+(((-1.0)*sj0*x267))+(((-1.0)*cj0*px)))))+(IKabs(((((-1.0)*cj0*x267))+((px*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x268=((1.0)*cj0);
CheckValue<IkReal> x270 = IKatan2WithCheck(IkReal(((0.043)+(((-1.0)*py*sj0))+(((-1.0)*px*x268)))),IkReal((((px*sj0))+(((-1.0)*py*x268)))),IKFAST_ATAN2_MAGTHRESH);
if(!x270.valid){
continue;
}
IkReal x269=x270.value;
j3array[0]=((-1.0)*x269);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x269)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x271=IKsin(j3);
IkReal x272=IKcos(j3);
evalcond[0]=(((px*sj0*x272))+(((-0.043)*x271))+((py*sj0*x271))+((cj0*px*x271))+(((-1.0)*cj0*py*x272)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x274 = IKatan2WithCheck(IkReal((((px*sj0))+(((-1.0)*cj0*py)))),IkReal(((-0.043)+((cj0*px))+((py*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x274.valid){
continue;
}
IkReal x273=x274.value;
j3array[0]=((-1.0)*x273);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x273)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x275=IKcos(j3);
IkReal x276=IKsin(j3);
IkReal x277=((1.0)*cj0);
evalcond[0]=(((px*sj0*x276))+(((-1.0)*px*x275*x277))+(((-1.0)*py*x276*x277))+(((0.043)*x275))+(((-1.0)*py*sj0*x275)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[2];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x278=pz*pz;
j0eval[0]=((((-1.0)*x278))+pp);
j0eval[1]=IKsign(((((-1000.0)*x278))+(((1000.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0, j3]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
CheckValue<IkReal> x279 = IKatan2WithCheck(IkReal(((43.0)*py)),IkReal(((43.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x279.valid){
continue;
}
CheckValue<IkReal> x280=IKPowWithIntegerCheck(IKsign(((((-1000.0)*(pz*pz)))+(((1000.0)*pp)))),-1);
if(!x280.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x279.value)+(((1.5707963267949)*(x280.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x281=IKcos(j0);
IkReal x282=IKsin(j0);
evalcond[0]=((-0.043)+((py*x282))+((px*x281)));
evalcond[1]=((((-1.0)*px*x282))+((py*x281)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j3eval[0]=((IKabs(((((-1.0)*px*sj0))+((cj0*py)))))+(IKabs(((-0.043)+((cj0*px))+((py*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x283=((1.0)*sj0);
j3eval[0]=((IKabs(((0.043)+(((-1.0)*py*x283))+(((-1.0)*cj0*px)))))+(IKabs(((((-1.0)*px*x283))+((cj0*py))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x284=((1.0)*px);
CheckValue<IkReal> x286 = IKatan2WithCheck(IkReal(((0.043)+(((-1.0)*cj0*x284))+(((-1.0)*py*sj0)))),IkReal(((((-1.0)*sj0*x284))+((cj0*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x286.valid){
continue;
}
IkReal x285=x286.value;
j3array[0]=((-1.0)*x285);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x285)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x287=IKsin(j3);
IkReal x288=IKcos(j3);
evalcond[0]=((((-0.043)*x287))+((cj0*px*x287))+(((-1.0)*px*sj0*x288))+((py*sj0*x287))+((cj0*py*x288)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x290 = IKatan2WithCheck(IkReal(((((-1.0)*px*sj0))+((cj0*py)))),IkReal(((-0.043)+((cj0*px))+((py*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x290.valid){
continue;
}
IkReal x289=x290.value;
j3array[0]=((-1.0)*x289);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x289)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x291=IKcos(j3);
IkReal x292=IKsin(j3);
IkReal x293=((1.0)*px);
evalcond[0]=((((-1.0)*cj0*x291*x293))+((cj0*py*x292))+(((-1.0)*py*sj0*x291))+(((0.043)*x291))+(((-1.0)*sj0*x292*x293)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x294=((43.0)*sj1);
IkReal x295=((1000.0)*sj1);
IkReal x296=((1000.0)*j2);
IkReal x297=((1000.0)*cj1*pz);
CheckValue<IkReal> x298 = IKatan2WithCheck(IkReal(((((116.2)*px))+((py*x294))+((px*x296))+(((-1.0)*px*x297)))),IkReal(((((-1.0)*py*x296))+(((-116.2)*py))+((py*x297))+((px*x294)))),IKFAST_ATAN2_MAGTHRESH);
if(!x298.valid){
continue;
}
CheckValue<IkReal> x299=IKPowWithIntegerCheck(IKsign(((((-1.0)*x295*(pz*pz)))+((pp*x295)))),-1);
if(!x299.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x298.value)+(((1.5707963267949)*(x299.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x300=IKcos(j0);
IkReal x301=IKsin(j0);
IkReal x302=(py*x300);
IkReal x303=(px*x301);
evalcond[0]=((-0.043)+((px*x300))+((py*x301)));
evalcond[1]=((((-1.0)*x303))+x302+((j2*sj1))+(((0.1162)*sj1)));
evalcond[2]=((-0.1162)+(((-1.0)*sj1*x302))+((cj1*pz))+(((-1.0)*j2))+((sj1*x303)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[1];
j3eval[0]=((IKabs(((((-1.0)*cj0*cj1*py))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))))+(IKabs(((-0.043)+((cj0*px))+((py*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
IkReal x304=((1.0)*cj0);
j3eval[0]=((IKabs(((0.043)+(((-1.0)*px*x304))+(((-1.0)*py*sj0)))))+(IKabs(((((-1.0)*pz*sj1))+((cj1*px*sj0))+(((-1.0)*cj1*py*x304))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x305=((1.0)*cj0);
CheckValue<IkReal> x307 = IKatan2WithCheck(IkReal(((0.043)+(((-1.0)*px*x305))+(((-1.0)*py*sj0)))),IkReal(((((-1.0)*pz*sj1))+((cj1*px*sj0))+(((-1.0)*cj1*py*x305)))),IKFAST_ATAN2_MAGTHRESH);
if(!x307.valid){
continue;
}
IkReal x306=x307.value;
j3array[0]=((-1.0)*x306);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x306)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x308=IKsin(j3);
IkReal x309=IKcos(j3);
IkReal x310=(cj1*x309);
evalcond[0]=((((-0.043)*x308))+(((-1.0)*pz*sj1*x309))+((cj0*px*x308))+(((-1.0)*cj0*py*x310))+((px*sj0*x310))+((py*sj0*x308)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x312 = IKatan2WithCheck(IkReal(((((-1.0)*cj0*cj1*py))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))),IkReal(((-0.043)+((cj0*px))+((py*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x312.valid){
continue;
}
IkReal x311=x312.value;
j3array[0]=((-1.0)*x311);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x311)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x313=IKsin(j3);
IkReal x314=IKcos(j3);
IkReal x315=((1.0)*x313);
IkReal x316=((1.0)*x314);
evalcond[0]=((((-1.0)*pz*sj1*x315))+(((0.043)*x314))+((cj1*px*sj0*x313))+(((-1.0)*py*sj0*x316))+(((-1.0)*cj0*px*x316))+(((-1.0)*cj0*cj1*py*x315)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x317=(px*sj1);
IkReal x318=((1000.0)*j2);
IkReal x319=(py*sj1);
CheckValue<IkReal> x320 = IKatan2WithCheck(IkReal((((x317*x318))+(((116.2)*x317))+(((43.0)*py)))),IkReal(((((-1.0)*x318*x319))+(((-116.2)*x319))+(((43.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x320.valid){
continue;
}
CheckValue<IkReal> x321=IKPowWithIntegerCheck(IKsign(((((-1000.0)*(pz*pz)))+(((1000.0)*pp)))),-1);
if(!x321.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x320.value)+(((1.5707963267949)*(x321.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x322=IKcos(j0);
IkReal x323=IKsin(j0);
IkReal x324=(py*x322);
IkReal x325=(px*x323);
evalcond[0]=((-0.043)+((py*x323))+((px*x322)));
evalcond[1]=((((-1.0)*x325))+x324+((j2*sj1))+(((0.1162)*sj1)));
evalcond[2]=((-0.1162)+(((-1.0)*sj1*x324))+((cj1*pz))+((sj1*x325))+(((-1.0)*j2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[1];
j3eval[0]=((IKabs(((((-1.0)*cj0*cj1*py))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))))+(IKabs(((-0.043)+((cj0*px))+((py*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
IkReal x326=((1.0)*cj0);
j3eval[0]=((IKabs(((0.043)+(((-1.0)*px*x326))+(((-1.0)*py*sj0)))))+(IKabs(((((-1.0)*cj1*py*x326))+(((-1.0)*pz*sj1))+((cj1*px*sj0))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x327=((1.0)*cj0);
CheckValue<IkReal> x329 = IKatan2WithCheck(IkReal(((0.043)+(((-1.0)*px*x327))+(((-1.0)*py*sj0)))),IkReal(((((-1.0)*cj1*py*x327))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x329.valid){
continue;
}
IkReal x328=x329.value;
j3array[0]=((-1.0)*x328);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x328)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x330=IKsin(j3);
IkReal x331=IKcos(j3);
IkReal x332=(cj1*x331);
evalcond[0]=((((-1.0)*pz*sj1*x331))+((py*sj0*x330))+(((-0.043)*x330))+((cj0*px*x330))+(((-1.0)*cj0*py*x332))+((px*sj0*x332)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x334 = IKatan2WithCheck(IkReal(((((-1.0)*cj0*cj1*py))+(((-1.0)*pz*sj1))+((cj1*px*sj0)))),IkReal(((-0.043)+((cj0*px))+((py*sj0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x334.valid){
continue;
}
IkReal x333=x334.value;
j3array[0]=((-1.0)*x333);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x333)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
IkReal x335=IKsin(j3);
IkReal x336=IKcos(j3);
IkReal x337=((1.0)*x335);
IkReal x338=((1.0)*x336);
evalcond[0]=(((cj1*px*sj0*x335))+(((-1.0)*cj0*cj1*py*x337))+(((-1.0)*py*sj0*x338))+(((-1.0)*pz*sj1*x337))+(((-1.0)*cj0*px*x338))+(((0.043)*x336)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x90=(r22*sj1);
IkReal x91=((9.9999999995e-6)*cj1);
IkReal x92=((0.99999999995)*cj1);
IkReal x93=((0.99999999995)*cj3);
IkReal x94=((9.9999999995e-6)*sj3);
IkReal x95=((1.0)*cj0);
IkReal x96=((1.0)*sj0);
IkReal x97=((1.0)*cj1);
IkReal x98=((9.9999999995e-6)*cj3);
IkReal x99=((9.9999999995e-6)*sj1);
IkReal x100=((0.99999999995)*sj1);
IkReal x101=((1.0)*sj1);
IkReal x102=((0.99999999995)*sj3);
IkReal x103=(((cj0*r10))+(((-1.0)*r00*x96)));
IkReal x104=((((-1.0)*r01*x96))+((cj0*r11)));
IkReal x105=(((cj0*r12))+(((-1.0)*r02*x96)));
IkReal x106=((((-1.0)*r10*x96))+(((-1.0)*r00*x95)));
IkReal x107=((((-1.0)*r11*x96))+(((-1.0)*r01*x95)));
IkReal x108=((((-1.0)*r12*x96))+(((-1.0)*r02*x95)));
IkReal x109=((((-1.0)*x103*x97))+(((-1.0)*r20*x101)));
IkReal x110=((((-1.0)*r21*x101))+(((-1.0)*x104*x97)));
IkReal x111=((((-1.0)*x90))+(((-1.0)*cj1*x105)));
IkReal x112=(cj3*x111);
new_r00=((((-1.0)*x103*x99))+((x102*x106))+((r20*x91))+(((-1.0)*x109*x93)));
new_r01=(((x106*x94))+(((-1.0)*r20*x92))+(((-1.0)*x109*x98))+((x100*x103)));
new_r02=(((cj3*x106))+((sj3*x109)));
new_r10=(((r21*x91))+((x102*x107))+(((-1.0)*x110*x93))+(((-1.0)*x104*x99)));
new_r11=(((x107*x94))+(((-1.0)*x110*x98))+(((-1.0)*r21*x92))+((x100*x104)));
new_r12=(((sj3*x110))+((cj3*x107)));
new_r20=(((x102*x108))+(((-1.0)*x111*x93))+(((-1.0)*x105*x99))+((r22*x91)));
new_r21=((((-1.0)*x111*x98))+(((-1.0)*r22*x92))+((x108*x94))+((x100*x105)));
new_r22=(((cj3*x108))+((sj3*(((((-1.0)*x105*x97))+(((-1.0)*x90)))))));
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((((0.99999999955)*new_r21))+(((-3.0000000012e-5)*new_r20)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.99999999955)*new_r20))+(((2.9999999985e-5)*new_r21)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((0.99999999955)*new_r21))+(((-3.0000000012e-5)*new_r20))))+IKsqr(((((0.99999999955)*new_r20))+(((2.9999999985e-5)*new_r21))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((0.99999999955)*new_r21))+(((-3.0000000012e-5)*new_r20))), ((((0.99999999955)*new_r20))+(((2.9999999985e-5)*new_r21))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x113=IKsin(j4);
IkReal x114=IKcos(j4);
evalcond[0]=((((-0.99999999955)*x114))+(((2.9999999985e-5)*x113))+new_r20);
evalcond[1]=((((-2.9999999985e-5)*x114))+(((-0.99999999955)*x113))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[1];
IkReal x115=new_r02*new_r02;
IkReal x116=new_r12*new_r12;
j6eval[0]=((((0.5)*(IKabs(((-3.9999999962e-5)+(((3.9999999962e-5)*x115))+(((3.9999999962e-5)*x116)))))))+(IKabs(((-0.000119999999886)+(((0.000119999999886)*x116))+(((0.000119999999886)*x115)))))+(((0.5)*(IKabs(((0.000159999999848)+(((-0.000159999999848)*x115))+(((-0.000159999999848)*x116)))))))+(((0.5)*(IKabs(((7.9999999924e-5)+(((-7.9999999924e-5)*x116))+(((-7.9999999924e-5)*x115))))))));
if( IKabs(j6eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j5, j6]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j6evalpoly[1];
IkReal x117=new_r02*new_r02;
IkReal x118=new_r12*new_r12;
IkReal x119=((7.9999999924e-5)+(((-7.9999999924e-5)*x118))+(((-7.9999999924e-5)*x117)));
op[0]=x119;
op[1]=0;
op[2]=((0.000159999999848)+(((-0.000159999999848)*x118))+(((-0.000159999999848)*x117)));
op[3]=0;
op[4]=x119;
polyroots4(op,zeror,numroots);
IkReal j6array[4], cj6array[4], sj6array[4], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[4]={true,true,true,true};
_nj6 = 4;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

IkReal x120=new_r02*new_r02;
IkReal x121=new_r12*new_r12;
IkReal x122=((3.9999999962e-5)*x120);
IkReal x123=((3.9999999962e-5)*x121);
IkReal x124=((-0.000119999999886)+(((0.000119999999886)*x120))+(((0.000119999999886)*x121)));
IkReal x125=((-3.9999999962e-5)+x122+x123);
j6evalpoly[0]=(((x124*(htj6*htj6)))+((x125*(htj6*htj6*htj6*htj6*htj6*htj6)))+x125+((x124*(htj6*htj6*htj6*htj6))));
if( IKabs(j6evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x126=(cj6*new_r02);
IkReal x127=(new_r12*sj6);
IkReal x128=(new_r02*sj6);
IkReal x129=(cj6*new_r12);
if( IKabs(((((-8.999999991e-15)*x126))+(((-1.0)*x129))+(((-1.0)*x128))+(((8.999999991e-15)*x127)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-8.999999991e-15)*x129))+(((-8.999999991e-15)*x128))+(((1.0)*x126))+(((-1.0)*x127)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-8.999999991e-15)*x126))+(((-1.0)*x129))+(((-1.0)*x128))+(((8.999999991e-15)*x127))))+IKsqr(((((-8.999999991e-15)*x129))+(((-8.999999991e-15)*x128))+(((1.0)*x126))+(((-1.0)*x127))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-8.999999991e-15)*x126))+(((-1.0)*x129))+(((-1.0)*x128))+(((8.999999991e-15)*x127))), ((((-8.999999991e-15)*x129))+(((-8.999999991e-15)*x128))+(((1.0)*x126))+(((-1.0)*x127))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[18];
IkReal x130=IKsin(j5);
IkReal x131=IKcos(j5);
IkReal x132=(new_r11*sj6);
IkReal x133=(cj6*sj4);
IkReal x134=((2.9999999985e-10)*cj6);
IkReal x135=(cj6*new_r01);
IkReal x136=(cj6*new_r02);
IkReal x137=(cj6*new_r10);
IkReal x138=((2.9999999985e-10)*sj4);
IkReal x139=((0.99999999995)*new_r12);
IkReal x140=((2.9999999985e-5)*sj4);
IkReal x141=(new_r00*sj6);
IkReal x142=((2.9999999985e-10)*cj4);
IkReal x143=((2.9999999985e-5)*cj4);
IkReal x144=(cj6*new_r00);
IkReal x145=(cj6*new_r12);
IkReal x146=((0.99999999995)*new_r02);
IkReal x147=((0.99999999995)*new_r10);
IkReal x148=((0.99999999955)*sj4);
IkReal x149=(new_r10*sj6);
IkReal x150=(new_r01*sj6);
IkReal x151=((0.99999999995)*new_r00);
IkReal x152=(new_r12*sj6);
IkReal x153=(cj6*new_r11);
IkReal x154=((0.99999999995)*new_r01);
IkReal x155=(new_r02*sj6);
IkReal x156=(cj4*x131);
IkReal x157=((9.9999999995e-6)*x130);
IkReal x158=(sj6*x131);
IkReal x159=((0.99999999955)*x130);
IkReal x160=((0.99999999995)*x131);
IkReal x161=((2.9999999985e-5)*x131);
IkReal x162=(cj6*x130);
IkReal x163=((8.999999991e-15)*x131);
IkReal x164=((9.9999999995e-6)*x131);
IkReal x165=(sj6*x130);
IkReal x166=((1.0)*x131);
IkReal x167=((0.99999999995)*x130);
evalcond[0]=(x163+x155+x145+(((1.0)*x130)));
evalcond[1]=((((-1.0)*x166))+x136+(((-1.0)*x152))+(((8.999999991e-15)*x130)));
evalcond[2]=((((-1.0)*x131*x143))+(((-1.0)*x131*x148))+x141+x137+((x130*x142)));
evalcond[3]=((((-1.0)*x131*x140))+(((0.99999999955)*x156))+x153+x150+((x130*x138)));
evalcond[4]=((((-1.0)*x131*x142))+x144+(((-1.0)*x149))+(((-1.0)*x130*x148))+(((-1.0)*x130*x143)));
evalcond[5]=(((cj4*x159))+x135+(((-1.0)*x132))+(((-1.0)*x131*x138))+(((-1.0)*x130*x140)));
evalcond[6]=((((8.999999991e-15)*x158))+(((8.999999991e-15)*x162))+(((-1.0)*cj6*x166))+new_r02+(((1.0)*x165)));
evalcond[7]=((((-8.999999991e-15)*x165))+((cj6*x163))+(((1.0)*x158))+new_r12+(((1.0)*x162)));
evalcond[8]=((((-1.0)*x143*x162))+(((-1.0)*x134*x156))+(((-1.0)*x143*x158))+(((-1.0)*x133*x159))+(((-1.0)*x148*x158))+new_r00+((x142*x165)));
evalcond[9]=(((cj4*cj6*x159))+(((0.99999999955)*sj6*x156))+(((-1.0)*x140*x158))+((x138*x165))+new_r01+(((-2.9999999985e-5)*x130*x133))+(((-2.9999999985e-10)*x131*x133)));
evalcond[10]=(((x143*x165))+((x142*x158))+((x148*x165))+((cj4*x130*x134))+(((-0.99999999955)*x131*x133))+new_r10+(((-1.0)*cj6*x131*x143)));
evalcond[11]=((((-1.0)*x133*x161))+((x140*x165))+(((-1.0)*cj4*sj6*x159))+((x138*x158))+(((0.99999999955)*cj6*x156))+(((2.9999999985e-10)*x130*x133))+new_r11);
evalcond[12]=((-9.9999999905e-6)+((x136*x164))+((x136*x167))+((cj6*x131*x139))+(((-1.0)*x152*x164))+(((-1.0)*x139*x165))+((x146*x158))+(((-1.0)*x145*x157))+(((-1.0)*x155*x157)));
evalcond[13]=((0.99999999995)+((x139*x158))+(((-1.0)*x136*x160))+((x139*x162))+((x136*x157))+(((-1.0)*x152*x157))+((x145*x164))+((x146*x165))+((x155*x164)));
evalcond[14]=(((x137*x164))+((x137*x167))+((x144*x157))+(((-1.0)*x144*x160))+((x141*x164))+((x141*x167))+(((-9.999999995e-6)*sj4))+((x147*x158))+(((-1.0)*x149*x157)));
evalcond[15]=((((-1.0)*x132*x157))+((x150*x164))+((x150*x167))+((x135*x157))+(((-1.0)*x135*x160))+(((9.999999995e-6)*cj4))+((x132*x160))+((x153*x167))+((x153*x164)));
evalcond[16]=(((x144*x164))+((x144*x167))+(((-1.0)*x137*x157))+((x137*x160))+((x141*x160))+(((-1.0)*x141*x157))+(((-0.9999999995)*sj4))+(((-1.0)*x147*x165))+(((-1.0)*x149*x164))+(((-2.99999999865e-5)*cj4)));
evalcond[17]=((((0.9999999995)*cj4))+(((-1.0)*x153*x157))+(((-1.0)*x150*x157))+(((-1.0)*x132*x164))+(((-1.0)*x132*x167))+((x150*x160))+((x135*x167))+((x135*x164))+(((-2.99999999865e-5)*sj4))+((x153*x160)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 17;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - master (978b44c7c1edbfcb66b33a34af2c6ad3)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
